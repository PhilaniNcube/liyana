create type "public"."api_check_status" as enum ('passed', 'failed', 'pending');

create type "public"."api_check_type" as enum ('credit_bureau', 'fraud_check', 'bank_verification', 'dha_otv_facial', 'email_verification', 'employment_verification', 'address_verification', 'cellphone_verification', 'id_verification', 'deceased_status');

create type "public"."api_vendor" as enum ('Experian', 'WhoYou', 'ThisIsMe');

create type "public"."application_status" as enum ('pre_qualifier', 'pending_documents', 'in_review', 'approved', 'declined', 'submitted_to_lender', 'submission_failed');

create type "public"."bank_account_type" as enum ('savings', 'transaction', 'current', 'business');

create type "public"."claim_status" as enum ('submitted', 'under_review', 'approved', 'denied', 'paid');

create type "public"."document_type" as enum ('id', 'bank_statement', 'payslip', 'proof_of_residence', 'contract', 'photo', 'credit_report', 'other', 'third_party_verification');

create type "public"."employment_type" as enum ('employed', 'self_employed', 'contract', 'unemployed', 'retired');

create type "public"."frequency" as enum ('monthly', 'quarterly', 'annually');

create type "public"."gender" as enum ('male', 'female', 'rather not say', 'other');

create type "public"."marital_status" as enum ('single', 'married', 'divorced', 'widowed', 'life_partner');

create type "public"."party_type" as enum ('individual', 'organization');

create type "public"."policy_document_type" as enum ('birth_certificate', 'death_certificate', 'marriage_certificate', 'identity_document', 'passport', 'third_party_document', 'proof_of_banking', 'payslip', 'drivers_license');

create type "public"."policy_status" as enum ('pending', 'active', 'lapsed', 'cancelled');

create type "public"."pre_application_status" as enum ('credit_passed', 'application_started', 'application_completed', 'abandoned', 'cancelled');

create type "public"."product_type" as enum ('funeral_policy', 'life_insurance', 'payday_loan');

create type "public"."relation_type" as enum ('spouse', 'child', 'parent', 'sibling', 'cousin', 'grandparent', 'in-law');

create type "public"."transaction_status" as enum ('pending', 'completed', 'failed');

create type "public"."transaction_type" as enum ('premium_payment', 'claim_payout', 'loan_disbursement', 'loan_repayment', 'refund');

create type "public"."user_role" as enum ('customer', 'admin', 'editor');

create sequence "public"."api_checks_id_seq";

create sequence "public"."applications_id_seq";

create sequence "public"."documents_id_seq";

create table "public"."api_checks" (
    "id" bigint not null default nextval('api_checks_id_seq'::regclass),
    "check_type" api_check_type not null,
    "vendor" api_vendor not null,
    "status" api_check_status not null,
    "response_payload" jsonb not null,
    "checked_at" timestamp with time zone not null default now(),
    "id_number" text not null,
    "profile_id" uuid
);


alter table "public"."api_checks" enable row level security;

create table "public"."applications" (
    "id" bigint not null default nextval('applications_id_seq'::regclass),
    "user_id" uuid not null,
    "id_number" text not null,
    "date_of_birth" date,
    "application_amount" numeric,
    "term" double precision not null,
    "status" application_status not null,
    "decline_reason" jsonb,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now(),
    "monthly_income" numeric,
    "work_experience" text,
    "employment_type" employment_type,
    "employer_name" text,
    "employer_address" text,
    "job_title" text,
    "employer_contact_number" text,
    "next_of_kin_name" text,
    "next_of_kin_phone_number" text,
    "next_of_kin_email" text,
    "home_address" text,
    "city" text,
    "loan_purpose" text,
    "bank_name" text,
    "bank_account_number" text,
    "branch_code" text,
    "employment_end_date" date,
    "loan_purpose_reason" text,
    "bank_account_type" bank_account_type,
    "bank_account_holder" text,
    "marital_status" marital_status,
    "dependants" integer,
    "nationality" text,
    "language" text,
    "gender" gender,
    "gender_other" text,
    "affordability" jsonb,
    "phone_number" text,
    "postal_code" text,
    "bravelender_application_id" text,
    "salary_date" smallint,
    "max_money_id" text
);


alter table "public"."applications" enable row level security;

create table "public"."approved_loans" (
    "id" bigint generated by default as identity not null,
    "application_id" bigint not null,
    "loan_term_days" integer not null,
    "interest_rate" numeric(5,2) not null,
    "approved_date" timestamp with time zone not null default now(),
    "total_repayment_amount" numeric(12,2) not null,
    "monthly_payment" numeric(12,2) not null,
    "next_payment_date" date,
    "status" text not null default 'active'::text,
    "created_at" timestamp with time zone default now(),
    "updated_at" timestamp with time zone default now(),
    "profile_id" uuid not null,
    "initiation_fee" numeric not null,
    "service_fee" numeric not null,
    "approved_loan_amount" numeric(12,2)
);


alter table "public"."approved_loans" enable row level security;

create table "public"."claim_payouts" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "claim_id" bigint not null,
    "beneficiary_party_id" uuid not null,
    "payout_date" timestamp with time zone not null,
    "amount" numeric not null
);


alter table "public"."claim_payouts" enable row level security;

create table "public"."claims" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "policy_id" bigint not null,
    "claimant_party_id" uuid not null,
    "claim_number" text not null,
    "date_of_incident" date not null,
    "date_filed" timestamp with time zone not null,
    "status" claim_status not null,
    "contact_details" jsonb
);


alter table "public"."claims" enable row level security;

create table "public"."documents" (
    "id" bigint not null default nextval('documents_id_seq'::regclass),
    "application_id" bigint not null,
    "user_id" uuid not null,
    "document_type" document_type not null,
    "storage_path" text not null,
    "uploaded_at" timestamp with time zone not null default now()
);


alter table "public"."documents" enable row level security;

create table "public"."loan_payments" (
    "id" bigint generated always as identity not null,
    "approved_loan_id" bigint not null,
    "payment_amount" numeric(12,2) not null,
    "payment_date" timestamp with time zone default now(),
    "payment_method" text,
    "status" text not null default 'completed'::text,
    "created_at" timestamp with time zone default now()
);


alter table "public"."loan_payments" enable row level security;

create table "public"."otv_checks" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "pin_code" text not null,
    "id_number" text not null,
    "application_id" bigint,
    "policy_id" bigint
);


alter table "public"."otv_checks" enable row level security;

create table "public"."parties" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "profile_id" uuid,
    "party_type" party_type not null,
    "first_name" text,
    "last_name" text,
    "organization_name" text,
    "date_of_birth" date,
    "id_number" text,
    "contact_details" jsonb,
    "address_details" jsonb,
    "updated_at" timestamp without time zone,
    "banking_details" jsonb
);


alter table "public"."parties" enable row level security;

create table "public"."policies" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "policy_holder_id" uuid not null,
    "policy_status" policy_status not null,
    "start_date" date default now(),
    "end_date" date,
    "premium_amount" numeric,
    "frequency" frequency not null,
    "updated_at" timestamp with time zone not null default now(),
    "product_type" product_type,
    "employment_details" jsonb,
    "coverage_amount" numeric,
    "user_id" uuid not null default auth.uid()
);


alter table "public"."policies" enable row level security;

create table "public"."policy_beneficiaries" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "policy_id" bigint not null,
    "beneficiary_party_id" uuid not null,
    "relation_type" relation_type not null,
    "allocation_percentage" numeric not null
);


alter table "public"."policy_beneficiaries" enable row level security;

create table "public"."policy_documents" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "user_id" uuid not null default auth.uid(),
    "document_type" policy_document_type not null,
    "path" text not null,
    "policy_id" bigint not null,
    "claim_id" bigint
);


alter table "public"."policy_documents" enable row level security;

create table "public"."policy_versions" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "policy_id" bigint not null,
    "version_number" smallint not null,
    "policy_data" jsonb not null,
    "effective_from" timestamp with time zone not null,
    "reason_for_change" text
);


alter table "public"."policy_versions" enable row level security;

create table "public"."pre_applications" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp without time zone not null default now(),
    "expires_at" timestamp without time zone,
    "profile_id" uuid not null,
    "user_id" uuid not null,
    "id_number" text not null,
    "credit_check_id" bigint not null,
    "credit_score" bigint not null,
    "status" pre_application_status not null,
    "application_id" bigint
);


alter table "public"."pre_applications" enable row level security;

create table "public"."profile_documents" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "profile_id" uuid not null,
    "document_type" document_type not null,
    "path" text not null
);


alter table "public"."profile_documents" enable row level security;

create table "public"."profiles" (
    "id" uuid not null,
    "full_name" text not null,
    "role" user_role not null default 'customer'::user_role,
    "created_at" timestamp with time zone not null default now(),
    "email" text default ((current_setting('request.jwt.claims'::text, true))::json ->> 'email'::text),
    "phone_number" text,
    "id_number" text
);


alter table "public"."profiles" enable row level security;

create table "public"."resend_emails" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "resend_id" text not null,
    "profile_id" uuid not null,
    "application_id" bigint,
    "loan_id" bigint,
    "policy_id" bigint
);


alter table "public"."resend_emails" enable row level security;

create table "public"."sms_logs" (
    "id" bigint generated by default as identity not null,
    "created_at" timestamp with time zone not null default now(),
    "phone_number" text not null,
    "message" character varying not null,
    "profile_id" uuid not null
);


alter table "public"."sms_logs" enable row level security;

create table "public"."transactions" (
    "id" uuid not null default gen_random_uuid(),
    "created_at" timestamp with time zone not null default now(),
    "source_policy_version_id" bigint,
    "source_claim_payout_id" bigint,
    "source_loan_id" bigint,
    "amount" numeric not null,
    "transaction_type" transaction_type not null,
    "transaction_status" transaction_status not null,
    "payment_ref" text,
    "metadata" jsonb
);


alter table "public"."transactions" enable row level security;

alter sequence "public"."api_checks_id_seq" owned by "public"."api_checks"."id";

alter sequence "public"."applications_id_seq" owned by "public"."applications"."id";

alter sequence "public"."documents_id_seq" owned by "public"."documents"."id";

CREATE UNIQUE INDEX api_checks_pkey ON public.api_checks USING btree (id);

CREATE UNIQUE INDEX applications_pkey ON public.applications USING btree (id);

CREATE UNIQUE INDEX approved_loans_pkey ON public.approved_loans USING btree (id);

CREATE UNIQUE INDEX claim_payouts_pkey ON public.claim_payouts USING btree (id);

CREATE UNIQUE INDEX claims_claim_number_key ON public.claims USING btree (claim_number);

CREATE UNIQUE INDEX claims_pkey ON public.claims USING btree (id);

CREATE UNIQUE INDEX documents_pkey ON public.documents USING btree (id);

CREATE INDEX idx_approved_loans_application_id ON public.approved_loans USING btree (application_id);

CREATE INDEX idx_approved_loans_profile_id ON public.approved_loans USING btree (profile_id);

CREATE INDEX idx_loan_payments_approved_loan_id ON public.loan_payments USING btree (approved_loan_id);

CREATE INDEX idx_pre_applications_created_at ON public.pre_applications USING btree (created_at);

CREATE INDEX idx_pre_applications_expires_at ON public.pre_applications USING btree (expires_at);

CREATE INDEX idx_pre_applications_profile_id ON public.pre_applications USING btree (profile_id);

CREATE INDEX idx_pre_applications_status ON public.pre_applications USING btree (status);

CREATE INDEX idx_pre_applications_user_id ON public.pre_applications USING btree (user_id);

CREATE UNIQUE INDEX loan_payments_pkey ON public.loan_payments USING btree (id);

CREATE UNIQUE INDEX otv_checks_pkey ON public.otv_checks USING btree (id);

CREATE UNIQUE INDEX parties_pkey ON public.parties USING btree (id);

CREATE UNIQUE INDEX policies_id_key ON public.policies USING btree (id);

CREATE UNIQUE INDEX policies_pkey ON public.policies USING btree (id);

CREATE UNIQUE INDEX policy_beneficiaries_pkey ON public.policy_beneficiaries USING btree (id);

CREATE UNIQUE INDEX policy_documents_pkey ON public.policy_documents USING btree (id);

CREATE UNIQUE INDEX policy_versions_pkey ON public.policy_versions USING btree (id);

CREATE UNIQUE INDEX pre_applications_pkey ON public.pre_applications USING btree (id);

CREATE UNIQUE INDEX profile_documents_pkey ON public.profile_documents USING btree (id);

CREATE UNIQUE INDEX profiles_pkey ON public.profiles USING btree (id);

CREATE UNIQUE INDEX resend_emails_pkey ON public.resend_emails USING btree (id);

CREATE UNIQUE INDEX sms_logs_pkey ON public.sms_logs USING btree (id);

CREATE UNIQUE INDEX transactions_pkey ON public.transactions USING btree (id);

alter table "public"."api_checks" add constraint "api_checks_pkey" PRIMARY KEY using index "api_checks_pkey";

alter table "public"."applications" add constraint "applications_pkey" PRIMARY KEY using index "applications_pkey";

alter table "public"."approved_loans" add constraint "approved_loans_pkey" PRIMARY KEY using index "approved_loans_pkey";

alter table "public"."claim_payouts" add constraint "claim_payouts_pkey" PRIMARY KEY using index "claim_payouts_pkey";

alter table "public"."claims" add constraint "claims_pkey" PRIMARY KEY using index "claims_pkey";

alter table "public"."documents" add constraint "documents_pkey" PRIMARY KEY using index "documents_pkey";

alter table "public"."loan_payments" add constraint "loan_payments_pkey" PRIMARY KEY using index "loan_payments_pkey";

alter table "public"."otv_checks" add constraint "otv_checks_pkey" PRIMARY KEY using index "otv_checks_pkey";

alter table "public"."parties" add constraint "parties_pkey" PRIMARY KEY using index "parties_pkey";

alter table "public"."policies" add constraint "policies_pkey" PRIMARY KEY using index "policies_pkey";

alter table "public"."policy_beneficiaries" add constraint "policy_beneficiaries_pkey" PRIMARY KEY using index "policy_beneficiaries_pkey";

alter table "public"."policy_documents" add constraint "policy_documents_pkey" PRIMARY KEY using index "policy_documents_pkey";

alter table "public"."policy_versions" add constraint "policy_versions_pkey" PRIMARY KEY using index "policy_versions_pkey";

alter table "public"."pre_applications" add constraint "pre_applications_pkey" PRIMARY KEY using index "pre_applications_pkey";

alter table "public"."profile_documents" add constraint "profile_documents_pkey" PRIMARY KEY using index "profile_documents_pkey";

alter table "public"."profiles" add constraint "profiles_pkey" PRIMARY KEY using index "profiles_pkey";

alter table "public"."resend_emails" add constraint "resend_emails_pkey" PRIMARY KEY using index "resend_emails_pkey";

alter table "public"."sms_logs" add constraint "sms_logs_pkey" PRIMARY KEY using index "sms_logs_pkey";

alter table "public"."transactions" add constraint "transactions_pkey" PRIMARY KEY using index "transactions_pkey";

alter table "public"."api_checks" add constraint "api_checks_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."api_checks" validate constraint "api_checks_profile_id_fkey";

alter table "public"."applications" add constraint "applications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."applications" validate constraint "applications_user_id_fkey";

alter table "public"."approved_loans" add constraint "approved_loans_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) not valid;

alter table "public"."approved_loans" validate constraint "approved_loans_application_id_fkey";

alter table "public"."approved_loans" add constraint "approved_loans_interest_rate_check" CHECK ((interest_rate >= (0)::numeric)) not valid;

alter table "public"."approved_loans" validate constraint "approved_loans_interest_rate_check";

alter table "public"."approved_loans" add constraint "approved_loans_loan_term_days_check" CHECK (((loan_term_days >= 5) AND (loan_term_days <= 60))) not valid;

alter table "public"."approved_loans" validate constraint "approved_loans_loan_term_days_check";

alter table "public"."approved_loans" add constraint "approved_loans_status_check" CHECK ((status = ANY (ARRAY['active'::text, 'paid_off'::text, 'defaulted'::text]))) not valid;

alter table "public"."approved_loans" validate constraint "approved_loans_status_check";

alter table "public"."approved_loans" add constraint "fk_approved_loans_profiles" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."approved_loans" validate constraint "fk_approved_loans_profiles";

alter table "public"."claim_payouts" add constraint "claim_payouts_beneficiary_party_id_fkey" FOREIGN KEY (beneficiary_party_id) REFERENCES parties(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."claim_payouts" validate constraint "claim_payouts_beneficiary_party_id_fkey";

alter table "public"."claim_payouts" add constraint "claim_payouts_claim_id_fkey" FOREIGN KEY (claim_id) REFERENCES claims(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."claim_payouts" validate constraint "claim_payouts_claim_id_fkey";

alter table "public"."claims" add constraint "claims_claim_number_key" UNIQUE using index "claims_claim_number_key";

alter table "public"."claims" add constraint "claims_claimant_party_id_fkey" FOREIGN KEY (claimant_party_id) REFERENCES parties(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."claims" validate constraint "claims_claimant_party_id_fkey";

alter table "public"."claims" add constraint "claims_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."claims" validate constraint "claims_policy_id_fkey";

alter table "public"."documents" add constraint "documents_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) not valid;

alter table "public"."documents" validate constraint "documents_application_id_fkey";

alter table "public"."documents" add constraint "documents_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."documents" validate constraint "documents_user_id_fkey";

alter table "public"."loan_payments" add constraint "loan_payments_approved_loan_id_fkey" FOREIGN KEY (approved_loan_id) REFERENCES approved_loans(id) not valid;

alter table "public"."loan_payments" validate constraint "loan_payments_approved_loan_id_fkey";

alter table "public"."loan_payments" add constraint "loan_payments_status_check" CHECK ((status = ANY (ARRAY['completed'::text, 'failed'::text, 'pending'::text]))) not valid;

alter table "public"."loan_payments" validate constraint "loan_payments_status_check";

alter table "public"."otv_checks" add constraint "otv_checks_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) not valid;

alter table "public"."otv_checks" validate constraint "otv_checks_application_id_fkey";

alter table "public"."otv_checks" add constraint "otv_checks_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) not valid;

alter table "public"."otv_checks" validate constraint "otv_checks_policy_id_fkey";

alter table "public"."parties" add constraint "parties_banking_details_is_object" CHECK (((banking_details IS NULL) OR (jsonb_typeof(banking_details) = 'object'::text))) not valid;

alter table "public"."parties" validate constraint "parties_banking_details_is_object";

alter table "public"."parties" add constraint "parties_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."parties" validate constraint "parties_profile_id_fkey";

alter table "public"."policies" add constraint "policies_id_key" UNIQUE using index "policies_id_key";

alter table "public"."policies" add constraint "policies_policy_holder_id_fkey" FOREIGN KEY (policy_holder_id) REFERENCES parties(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."policies" validate constraint "policies_policy_holder_id_fkey";

alter table "public"."policies" add constraint "policies_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."policies" validate constraint "policies_user_id_fkey";

alter table "public"."policy_beneficiaries" add constraint "policy_beneficiaries_beneficiary_party_id_fkey" FOREIGN KEY (beneficiary_party_id) REFERENCES parties(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."policy_beneficiaries" validate constraint "policy_beneficiaries_beneficiary_party_id_fkey";

alter table "public"."policy_beneficiaries" add constraint "policy_beneficiaries_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."policy_beneficiaries" validate constraint "policy_beneficiaries_policy_id_fkey";

alter table "public"."policy_documents" add constraint "policy_documents_claim_id_fkey" FOREIGN KEY (claim_id) REFERENCES claims(id) not valid;

alter table "public"."policy_documents" validate constraint "policy_documents_claim_id_fkey";

alter table "public"."policy_documents" add constraint "policy_documents_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) not valid;

alter table "public"."policy_documents" validate constraint "policy_documents_policy_id_fkey";

alter table "public"."policy_documents" add constraint "policy_documents_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) not valid;

alter table "public"."policy_documents" validate constraint "policy_documents_user_id_fkey";

alter table "public"."policy_versions" add constraint "policy_versions_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) not valid;

alter table "public"."policy_versions" validate constraint "policy_versions_policy_id_fkey";

alter table "public"."pre_applications" add constraint "pre_applications_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."pre_applications" validate constraint "pre_applications_application_id_fkey";

alter table "public"."pre_applications" add constraint "pre_applications_credit_check_id_fkey" FOREIGN KEY (credit_check_id) REFERENCES api_checks(id) not valid;

alter table "public"."pre_applications" validate constraint "pre_applications_credit_check_id_fkey";

alter table "public"."pre_applications" add constraint "pre_applications_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."pre_applications" validate constraint "pre_applications_profile_id_fkey";

alter table "public"."pre_applications" add constraint "pre_applications_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."pre_applications" validate constraint "pre_applications_user_id_fkey";

alter table "public"."profile_documents" add constraint "profile_documents_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."profile_documents" validate constraint "profile_documents_profile_id_fkey";

alter table "public"."profiles" add constraint "profiles_id_fkey" FOREIGN KEY (id) REFERENCES auth.users(id) not valid;

alter table "public"."profiles" validate constraint "profiles_id_fkey";

alter table "public"."resend_emails" add constraint "resend_emails_application_id_fkey" FOREIGN KEY (application_id) REFERENCES applications(id) not valid;

alter table "public"."resend_emails" validate constraint "resend_emails_application_id_fkey";

alter table "public"."resend_emails" add constraint "resend_emails_loan_id_fkey" FOREIGN KEY (loan_id) REFERENCES approved_loans(id) not valid;

alter table "public"."resend_emails" validate constraint "resend_emails_loan_id_fkey";

alter table "public"."resend_emails" add constraint "resend_emails_policy_id_fkey" FOREIGN KEY (policy_id) REFERENCES policies(id) not valid;

alter table "public"."resend_emails" validate constraint "resend_emails_policy_id_fkey";

alter table "public"."resend_emails" add constraint "resend_emails_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."resend_emails" validate constraint "resend_emails_profile_id_fkey";

alter table "public"."sms_logs" add constraint "sms_logs_profile_id_fkey" FOREIGN KEY (profile_id) REFERENCES profiles(id) not valid;

alter table "public"."sms_logs" validate constraint "sms_logs_profile_id_fkey";

alter table "public"."transactions" add constraint "transactions_source_claim_payout_id_fkey" FOREIGN KEY (source_claim_payout_id) REFERENCES claim_payouts(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."transactions" validate constraint "transactions_source_claim_payout_id_fkey";

alter table "public"."transactions" add constraint "transactions_source_loan_id_fkey" FOREIGN KEY (source_loan_id) REFERENCES approved_loans(id) ON UPDATE CASCADE ON DELETE CASCADE not valid;

alter table "public"."transactions" validate constraint "transactions_source_loan_id_fkey";

alter table "public"."transactions" add constraint "transactions_source_policy_version_id_fkey" FOREIGN KEY (source_policy_version_id) REFERENCES policy_versions(id) not valid;

alter table "public"."transactions" validate constraint "transactions_source_policy_version_id_fkey";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.handle_new_user()
 RETURNS trigger
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
begin
  insert into public.profiles (id, full_name, email, phone_number)
  values (new.id, new.raw_user_meta_data->>'full_name', new.email, new.raw_user_meta_data->>'phone_number');
  return new;
end;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user_signup(user_id uuid, user_full_name text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
    user_email text;
BEGIN
    -- Get the email from auth.users table
    SELECT email INTO user_email
    FROM auth.users
    WHERE id = user_id;
    
    -- Insert into profiles with the email
    INSERT INTO public.profiles (id, full_name, email, role)
    VALUES (user_id, user_full_name, user_email, 'customer');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.handle_new_user_signup(user_id uuid, user_full_name text, phone_number text)
 RETURNS void
 LANGUAGE plpgsql
 SECURITY DEFINER
 SET search_path TO ''
AS $function$
DECLARE
    user_email text;
BEGIN
    -- Get the email from auth.users table
    SELECT email INTO user_email
    FROM auth.users
    WHERE id = user_id;
    
    -- Insert into profiles with the email and phone number
    INSERT INTO public.profiles (id, full_name, email, phone_number, role)
    VALUES (user_id, user_full_name, user_email, phone_number, 'customer');
END;
$function$
;

CREATE OR REPLACE FUNCTION public.is_admin()
 RETURNS boolean
 LANGUAGE plpgsql
 SECURITY DEFINER
AS $function$
DECLARE
    user_role_value user_role;
    user_email text;
BEGIN
    -- Get the current user's ID from the JWT token
    IF auth.uid() IS NULL THEN
        RETURN false;
    END IF;
    
    -- Get the user's role and email from the profiles table
    SELECT role, email INTO user_role_value, user_email
    FROM profiles
    WHERE id = auth.uid();
    
    -- Check if user exists in profiles table
    IF user_role_value IS NULL THEN
        RETURN false;
    END IF;
    
    -- Check if user has admin role AND email ends with @liyanafinance.co.za
    RETURN (
        user_role_value = 'admin'::user_role 
        AND user_email IS NOT NULL 
        AND user_email LIKE '%@liyanafinance.co.za'
    );
END;
$function$
;

CREATE OR REPLACE FUNCTION public.update_pre_applications_updated_at()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$function$
;

create policy "Admin full access on api_checks"
on "public"."api_checks"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "Enable insert for authenticated users only"
on "public"."api_checks"
as permissive
for insert
to authenticated
with check (true);


create policy "Select: profile view own checks"
on "public"."api_checks"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = profile_id));


create policy "Admin can delete all records from applications"
on "public"."applications"
as permissive
for delete
to authenticated
using ((( SELECT (auth.jwt() ->> 'email'::text)) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin can insert records into applications"
on "public"."applications"
as permissive
for insert
to authenticated
with check ((( SELECT (auth.jwt() ->> 'email'::text)) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin can update all records in applications"
on "public"."applications"
as permissive
for update
to authenticated
using ((( SELECT (auth.jwt() ->> 'email'::text)) ~~ '%@liyanafinance.co.za%'::text))
with check ((( SELECT (auth.jwt() ->> 'email'::text)) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin full access on applications"
on "public"."applications"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "Users can delete their own applications"
on "public"."applications"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can insert their own applications"
on "public"."applications"
as permissive
for insert
to authenticated
with check (true);


create policy "Users can update their own applications"
on "public"."applications"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Users can view their own applications"
on "public"."applications"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id));


create policy "Admin full access on approved_loans"
on "public"."approved_loans"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User view own approved loans"
on "public"."approved_loans"
as permissive
for select
to authenticated
using (((profile_id = auth.uid()) OR is_admin()));


create policy "Admin full access on claim_payouts"
on "public"."claim_payouts"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User read claim payouts"
on "public"."claim_payouts"
as permissive
for select
to authenticated
using (true);


create policy "Admin full access on claims"
on "public"."claims"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User access on claims"
on "public"."claims"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Admin full access on documents"
on "public"."documents"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User access on documents"
on "public"."documents"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Admin full access on loan_payments"
on "public"."loan_payments"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User view loan payments"
on "public"."loan_payments"
as permissive
for select
to authenticated
using (true);


create policy "Admin full access on otv_checks"
on "public"."otv_checks"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "Admin full access on parties"
on "public"."parties"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User own profile parties"
on "public"."parties"
as permissive
for all
to authenticated
using (((profile_id = auth.uid()) OR is_admin()))
with check (((profile_id = auth.uid()) OR is_admin()));


create policy "Admin full access on policies"
on "public"."policies"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User access on policies"
on "public"."policies"
as permissive
for all
to authenticated
using (((user_id = auth.uid()) OR is_admin()))
with check (((user_id = auth.uid()) OR is_admin()));


create policy "Admin full access on policy_beneficiaries"
on "public"."policy_beneficiaries"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User access on policy_beneficiaries"
on "public"."policy_beneficiaries"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Admin full access on policy documents"
on "public"."policy_documents"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User can perform actions on their own documents"
on "public"."policy_documents"
as permissive
for all
to authenticated
using (((user_id = auth.uid()) OR is_admin()))
with check (((user_id = auth.uid()) OR is_admin()));


create policy "Admin full access on policy_versions"
on "public"."policy_versions"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User access on policy_versions"
on "public"."policy_versions"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "A User can view their own resource"
on "public"."pre_applications"
as permissive
for all
to authenticated
using ((( SELECT auth.uid() AS uid) = user_id))
with check ((( SELECT auth.uid() AS uid) = user_id));


create policy "Admin Can perform Any Action"
on "public"."pre_applications"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "Admin full access on profile_documents"
on "public"."profile_documents"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User own documents"
on "public"."profile_documents"
as permissive
for all
to authenticated
using (((profile_id = auth.uid()) OR is_admin()))
with check (((profile_id = auth.uid()) OR is_admin()));


create policy "Admin can delete all records from profiles"
on "public"."profiles"
as permissive
for delete
to authenticated
using ((( SELECT (auth.jwt() ->> 'email'::text)) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin can insert records into profiles"
on "public"."profiles"
as permissive
for insert
to authenticated
with check (((auth.jwt() ->> 'email'::text) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin can update all records in profiles"
on "public"."profiles"
as permissive
for update
to authenticated
using (((auth.jwt() ->> 'email'::text) ~~ '%@liyanafinance.co.za%'::text))
with check (((auth.jwt() ->> 'email'::text) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin can view all records"
on "public"."profiles"
as permissive
for select
to authenticated
using (((auth.jwt() ->> 'email'::text) ~~ '%@liyanafinance.co.za%'::text));


create policy "Admin full access on profiles"
on "public"."profiles"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User own profile"
on "public"."profiles"
as permissive
for all
to authenticated
using (((auth.uid() = id) OR is_admin()))
with check (((auth.uid() = id) OR is_admin()));


create policy "Users can delete their own profiles"
on "public"."profiles"
as permissive
for delete
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Users can insert their own profiles"
on "public"."profiles"
as permissive
for insert
to authenticated
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Users can update their own profiles"
on "public"."profiles"
as permissive
for update
to authenticated
using ((( SELECT auth.uid() AS uid) = id))
with check ((( SELECT auth.uid() AS uid) = id));


create policy "Users can view their own profiles"
on "public"."profiles"
as permissive
for select
to authenticated
using ((( SELECT auth.uid() AS uid) = id));


create policy "Admin Users can perform any action"
on "public"."resend_emails"
as permissive
for all
to public
using (is_admin())
with check (is_admin());


create policy "Save SMS History"
on "public"."sms_logs"
as permissive
for all
to authenticated
using (true)
with check (true);


create policy "Admin full access on transactions"
on "public"."transactions"
as permissive
for all
to authenticated
using (is_admin())
with check (is_admin());


create policy "User view transactions"
on "public"."transactions"
as permissive
for select
to authenticated
using (true);


CREATE TRIGGER update_pre_applications_updated_at BEFORE UPDATE ON public.pre_applications FOR EACH ROW EXECUTE FUNCTION update_pre_applications_updated_at();


